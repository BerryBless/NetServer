시뮬레이션
- https://www.cs.usfca.edu/~galles/visualization/RedBlack.html


enum NODE_COLOR
{
	BLACK = 0,
	RED
};

struct stNODE
{
	struct stNODE *pParent;
	struct stNODE *pLeft;
	struct stNODE *pRight;

	NODE_COLOR Color;	

	int iData;
};


stNODE Nil;	// 끝 리프노드. 무조건 블랙 / 데이터 무 / NULL 의 같은 용도.

Nil.Color = BLACK;
Nil.pParent = NULL;
Nil.pLeft = NULL;
Nil.pRight = NULL;





# 특징 

1. 각 노드는 부모의 포인터를 가진다. (편의를 위해 일반적으로 그러 함)

2. 각 노드는 RED, BLOCK 의 색상값을 가진다.

3. 리프노드 (끝 잎노드) 를 표현하기 위해 Nil 이라는 공통된 노드를 사용한다.



# 노드 구성 조건

1. 모든 노드는 레드, 블랙 중 하나이다.

2. 루트 노드는 블랙 이다.

3. 리프(잎) 노드는 블랙 이다.

4. 레드 노드의 자식은 블랙 이다. 

	+ 블랙 노드의 자식은 무슨 색이든 가능
	+ 레드 노드의 부모는 무조건 블랙
	+ 레드 노드의 자식도 무조건 블랙

	
5. 루트노드 부터 리프노드 까지 모든 경로의 블랙의 수는 같다.



# 레드블랙 트리란 ?

- 위의 5가지 조건을 만족하는 이진서치 트리


# 위 조건을 만족하면 왜 성능이 좋은가 ?

- 이진트리의 검색 성능을 좌우하는 것은 리프노드 까지의 깊이의 밸런스.

- 한쪽으로의 쏠림이 적은 상태가 가장 최고의 상황.

- 레드블랙트리는 각노드에 레드,블랙의 상태를 만들어서

  레드 노드는 연달아 올 수 없으며,
 
  루트 > 리프 까지의 모든 경우에 대해 블랙 개수를 일치하게 한다.



== 15개 노드의 최고 상황 ==============================

 
                    B

             R               R

         B       B       B       B
 
      R    R   R   R   R   R   R   R
 
    N  N N  N N N N N N N N N N N N N

어떤 경우에도 4번만에 검색 가능. (15개 노드)

Root > Leaf 의 모든 경우에 대해 블랙 2회.



== 15개 노드의 레드블랙 최악 상황 =====================


                      B

             B                   R

         B       B         B          B
 
       N  N     N  N    B     B    R     R
                      
                       N N   N N  B  B   B   B

                                 NN  NN  NN  NN


3회 ~ 5회 만에 검색 가능. (15개 노드)


- 레드의 자식은 블랙 이어야 한다

- Root > Leaf 의 블랙 개수는 모두 같아야 한다.

  위 2개의 조건으로 인해서 깊이 밸런스에 최대최소 범위가 생겨나게 된다.








최단깊이 - 블랙노드로만 이루어진 경로

최장깊이 - 블랙과 레드가 반복되는 경로

고로 최장은 최단깊이 X 2 까지 가능.



이진서치 트리에서 최악의 상황

최단깊이 - 0

최장깊이 - (노드개수 - 1)

이런 가능성도 있으므로 레드블랙 트리는 전체 밸런스가 훨씬 좋은 이진트리임





# Leaf 를 표시하는 Nil 노드.

레드블랙 트리에서는 데이터를 사용하지 않는 더미노드를 하나 준비함.

이는 무조건 블랙노드이며,  모든 리프에 Nil 노드를 연결한다.

레드블랙의 3번조건, "모든 리프는 블랙이다" 의 조건을 만족하기 위한

NULL 대신 들어간 더미노드임.




# 모든 삽입과 삭제는 이진서치 트리를 기본으로 함.

삽입 및 삭제 후 레드,블랙의 밸런스를 맞추는 작업이 추가적으로 들어감.





# 노드의 회전

노드의 깊이 밸런스를 맞추기 위해 필요한 기본 기능은 회전.


- Node N 을 기준으로 우회전

       N

   A       D

 B   C   E   F


        < N 에서 우회전 >

       A

   B       N

        C     D

            E    F


N 의 왼쪽 자식 (A) 이 N 의 위치로 오며 N 은 왼쪽자식(A) 의 오른편으로 붙음.

이때 N 의 왼쪽자식 (A) 의 오른편 자식 (C) 은  N 의 왼편으로 붙음.




- Node N 을 기준으로 좌회전


       N

   A       D

 B   C   E   F


        < N 에서 좌회전 >

       D

     N    F

   A   E

 B   C  

N 의 오른 자식 (D) 이 N 의 위치로 오며 N 은 왼쪽자식(D) 의 왼편으로 붙음.

이때 N 의 오른자식 (D) 의 왼편 자식 (E) 은  N 의 오른편으로 붙음.








# 노드 삽입 후 밸런스 맞추기

새로 삽입되는 노드는 무조건 RED

새로 삽입되는 노드는 무조건 끝단에 들어감.




레드.블랙 트리 조건확인.

1. 모든 노드는 레드/블랙 이다. 
2. 루트 노드는 블랙이다. 
3. 리프 노드는 블랙이다. 
4. 레드 노드의 자식은 블랙이다. 
5. 루트부터 리프까지 어떤 경우에도 블랙 개수는 동일하다. 

------------------------
신규 노드의 부모가 블랙이라면 전혀 문제가 없음.
아래의 문제 상황은 부모가 레드인 경우 해당됨.
------------------------


4번을 해결하기 위해서 삼촌 (부모의 형제) 노드의 색상을 확인 해야한다.

부모의 형제 노드를 확인하는 이유!  레드,블랙 트리에서의 가장 중요한 부분은

'모든 경로에 대한 블랙노드의 개수일치' 이다

새로운 노드가 추가되면, 삼촌노드와 블랙 개수가 맞추어져야 한다. 

할아버지를 기준으로 좌우의 밸런스 !!!

(부모 > 할아버지 > 옆 자식) 




- 4번 조건에 대한 문제 상황

1. 부모 레드, 삼촌도 레드.
2. 부모 레드, 삼촌은 블랙, 나는 부모의 오른쪽 레드, , .
3. 부모 레드, 삼촌은 블랙, 나는 부모의 왼쪽 레드, , .















1. 부모와 삼촌을 블랙으로 바꾸고,  할아버지는 레드로 바꾼다.

   할아버지가 레드로 바뀜으로 인해서,  할아버지 상단의 색상도 모두 비교를 해보아야 한다.

   그래서 결국 ROOT 노드까지 올라가면서 이를 반복 확인 해야한다.

   할아버지를 새 노드로 잡고 다시 확인.












2. 나는 오른레드, 부모도 레드, 삼촌은 블랙 상황.

   색상만 맞추는걸로 끝내지 않고,  회전을 통해서 밸런스를 맞춰 준다.

   회전을 위해선 좌측 또는 우측의 한쪽 방향으로 노드가 몰려있어야 함

   그러므로 우선  3번조건 상황으로 만든다.


   나는 레드,  부모의 오른쪽 노드,  부모도 레드, 인 경우에는

   부모기준으로 좌회전하여 신규노드를 부모의 위치로 올리고,

   부모를 신규노드 왼쪽 자식으로 옮긴다


   이로서 2번 상황은 3번 상황으로 변경 되었음.


   이를 하는 이유는 3번 상황에서 할아버지의 우회전을 통해 해결을 해야 하는데
  
   레드노드가 부모의 오른자식이면 할아버지 오른쪽으로 레드노드가 넘어간다.
  
   이때, 할아버지가 레드가 될 예정이므로 문제가 발생함.




3. 나는 왼레드, 부모도 레드, 삼촌은 블랙	

   부모를 블랙으로 

   할아버지는 레드로

   할아버지 기준으로 우회전! 

   

# 모든 문제는 부모가 레드인 경우이므로 할아버지는 블랙이다.



//////////////////////////////////////////////////////////////////////////////////////////////////////
// 삭제
//////////////////////////////////////////////////////////////////////////////////////////////////////


# 레드블랙 트리 삭제

- 삭제 과정은 이진서치트리와 같음.

삭제 할 노드를 찾고, 그 자리를 대체 할 노드

   + 삭제노드의 자식이 하나 이하라면 자기 자신을 바로 삭제

   + 삭제노드에 자식이 둘이라면 
       - 오른 자식의 가장 작은 노드
       - 왼 자식의 가장 큰 노드

를 찾아서 노드(데이터)를 교체 한 뒤에 최종적인 삭제 노드 
(교체되어 진짜 삭제 되는 노드)에 대해서 밸런스 작업이 추가 되어야 한다.

이후부터 삭제 노드란 사용자가 삭제 하려던 데이터를 가진 노드가 아니고
지우고자 하는 데이터를 대신 하여 검색된 노드를 뜻함.


선조건, 최종 삭제 노드는 자식이 하나 이하임.(Nil제외) 두개인 상황은 없음.
  








부모로부터 내가 왼쪽인지 오른쪽인지에 따라서 분기를 나누어 작업을 해야한다.
삽입의 경우는 할아버지 기준으로 나누었으나, 삭제는 부모 기준으로 좌우를 나눔.


일단 부모 기준으로 내가 왼쪽에 있다는 조건으로 설명.



1. 삭제 노드가 레드인 경우

   추가 작업이 필요 없다.


   삭제 노드가 레드라면 부모는 블랙이다.

   삭제 노드가 레드라면 자식 노드는 블랙이다.

   레드 노드는 삭제가 되어도 블랙 밸런스에 문제가 없다.

   그러므로 삭제 노드가 레드라면 그냥 지워주면 끝.




------ 반복 검사 시작부 ------------

아래의 상황들은 실제로 삭제노드는 블랙이고, (레드면 할일이 없응께)

삭제노드의 자식노드 역시 블랙이라는 조건하에 진행.

(지운 노드의 자식이 레드다! ->  그 레드를 그냥 블랙으로 바꾸고 끝낼 수 있다)
                                    


2. 삭제 노드가 블랙인 경우

   블랙노드를 삭제하면 각 리프까지의 블랙 개수가 틀어지므로
   밸런스 작업이 필요함.

   또는 삭제노드(블랙) 의 부모와 자식이 레드인경우 삭제 후 
   레드 - 레드가 되므로 문제.


   2.1 삭제 노드의 부모와 자식이 모두 레드인 경우

   2.2 삭제 노드의 형제가 레드

   2.3 삭제 노드의 형제가 블랙이고 형제의 양쪽 자식이 블랙 (부모가 레드인지 아닌지에 따라)

   2.4 삭제 노드의 형제가 블랙이고 형제의 왼자식이 레드, 오른자식은 블랙

   2.5 삭제 노드의 형제가 블랙이고 형제의 오른자식이 레드


	부모기준으로 좌우의 블랙 밸런스를 맞추는게 목표.

	내쪽의 블랙이 지워졌다면 형제라인의 블랙을 제거 해야함.

	하지만 제거 한다는건 말이 안되므로, 회전을 통해서 우리쪽으로 블랙을 끌어온다.


-------------------------------------


   2.1 삭제 노드의 부모와 자식이 모두 레드인 경우
	(또는 삭제 노드의 자식이 레드인가?)

	부모와 자식이 모두 레드라면 삭제노드(블랙)이 빠짐으로
        삭제노드 라인의 블랙이 하나 줄어들고 레드 - 레드의 문제가 됨.

        삭제 노드의 자식(레드) 을 블랙으로 바꾸어줌으로 문제 해결


	이는 다르게 보면 삭제노드의 자식 (밀치고 들어온 노드) 가 레드인가?
	의 조건으로 한정지을 수 있다.

	새로 자리한 노드가 레드라면 이를 블랙으로 바꾸는걸로 마무리 됨.





   2.2 삭제 노드의 형제가 레드


	형제를 블랙으로 바꿈
	부모를 기준으로 좌회전!!!
	기존 부모를 레드로 바꿈.
	
	그리고 현재노드 (삭제 후 들어온노드, 삭제노드의 자식) 기준으로 처음부터 재작업.

	이 경우는 좌회전으로 삭제노드 방향이 한칸씩 내려가며
	되려 더 깊이가 깊어진 상태로 재검사를 하게 됨.


	+ 형제가 레드라면 형제는 블랙이 존재하는 두 자식 라인을 가지고 있게됨.
	+ 이때 좌회전을 하면 형제가 부모가 되면서 형제의 기존 왼자식이 내쪽으로 넘어오게 됨
	+ 이로서 형제가 블랙이 되는 상황을 만든다
	? 부모가 원래 레드였으면 어떡하는가?,  형제가 레드므로 부모가 레드일 수 없음.








   2.3 삭제 노드의 형제가 블랙이고 형제의 양쪽 자식이 블랙


	이때는 형제를 레드로

	이걸로 내 가족 밸런스 처리는 끝. (내쪽이 블랙-1 이었음, 형제도 블랙 -1 해주었음)
	하지만 내 가족 전체에서 블랙이 하나 빠졌으므로, 할아버지 입장에서는
	내 부모라인으로 블랙 -1 상태가 됨.

	그래서 내 부모를 기준으로 처음부터 다시 처리.
	(내 부모를 삭제노드의 자식으로 봄)

	? 만약, 부모가 레드였다면? (형제를 레드로 바꾸는데서 문제발생?)
	어차피 부모를 기준으로 2.1 부터 다시 체크하게 되므로
	삭제 노드가 레드인 조건으로 들어가서, 블랙으로 변경후 상황종료.




   2.4 삭제 노드의 형제가 블랙이고 형제의 왼자식이 레드, 오른자식이 블랙




	형제의 왼자식을 블랙으로

	형제를 레드로

	형제 기준으로 우회전

	
	이걸로 2.5 상황으로 맞추어짐. 
		

	형제의 블랙을 -> 레드
	형제 자식 하나를 -> 블랙

	블랙으로 만든 자식을 부모로 올리고,
	기존의 부모는 레드로 바꿈.



   2.5 삭제 노드의 형제가 블랙이고 형제의 오른자식이 레드


	형제 컬러를 부모 컬러로.

	부모 컬러는 블랙

	형제의 오른자식은 블랙

	부모기준 좌회원   
	
	+ 이 상황은 형제(블랙)의 자식에 레드가 존재 함으로서
	+ 간단하게 형제쪽에 블랙을 추가하여 내쪽에 블랙을 증가시킬 수 있는 상황!

	+ 부모의 컬러를 형제에게 넣으므로서 회전 후 부모의 색상은 동일할 것이며
	+ 기존 부모를 블랙으로 바꾸어서 이를 회전하여 삭제노드 쪽으로 넘김.
	+ 이렇게 삭제된 블랙을 +1  시키고, 블랙 이었던 형제가 부모역할을 하면서 
	+ 형제 라인의 블랙이 -1 되었음, 이를 본래 형제의 레드자식을 블랙으로 바꿔서 해결
   


       















