#pragma once
#include "CMemory.h"
/*
------------------------------------------------------------------------------------------

# 레드블랙 트리란 ?

- 위의 5가지 조건을 만족하는 이진서치 트리


# 위 조건을 만족하면 왜 성능이 좋은가 ?

- 이진트리의 검색 성능을 좌우하는 것은 리프노드 까지의 깊이의 밸런스.

- 한쪽으로의 쏠림이 적은 상태가 가장 최고의 상황.

- 레드블랙트리는 각노드에 레드,블랙의 상태를 만들어서

  레드 노드는 연달아 올 수 없으며,

  루트 > 리프 까지의 모든 경우에 대해 블랙 개수를 일치하게 한다.

 # 노드 구성 조건

1. 모든 노드는 레드, 블랙 중 하나이다.

2. 루트 노드는 블랙 이다.

3. 리프(잎) 노드는 블랙 이다.

4. 레드 노드의 자식은 블랙 이다.

	+ 블랙 노드의 자식은 무슨 색이든 가능
	+ 레드 노드의 부모는 무조건 블랙
	+ 레드 노드의 자식도 무조건 블랙


5. 루트노드 부터 리프노드 까지 모든 경로의 블랙의 수는 같다.

------------------------------------------------------------------------------------------ */
class CRedBlackTree {
public:
	enum NODE_COLOR {
		BLACK = 0,
		RED
	};

	struct stNODE {
		stNODE *pParent;	// 부모
		stNODE *pLeft;		// 왼쪽자식
		stNODE *pRight;		// 오른쪽자식

		long long Data;	// 데이터(키)
		NODE_COLOR Color;	// 나의 색

	};
private:
	//////////////////////////////////////////////////////////////////////////
	// 맴버 변수
	// 
	//////////////////////////////////////////////////////////////////////////
	stNODE *_root;	// 루트 노드
	stNODE *_Nil;	// 끝 리프노드. 무조건 블랙 / 데이터 무 / NULL 의 같은 용도.


	int _d;	// 트리의 지름
	int _hc;// 트리의 높이
public:
	//////////////////////////////////////////////////////////////////////////
	// 	   생성자 소멸자
	// 
	//////////////////////////////////////////////////////////////////////////

	CRedBlackTree();
	~CRedBlackTree();






#pragma region 삽입삭제


	//////////////////////////////////////////////////////////////////////////
	// 노드 삽입
	// iData값을 가진 노드를 삽입한다.
	// 
	// Parameters: 입력할 데이터.
	// Return: (bool) 삽입 성공 여부 (true : 삽입성공 / false : 삽입실패)
	//////////////////////////////////////////////////////////////////////////
	bool InsertNode(long long iData);

	//////////////////////////////////////////////////////////////////////////
	// 노드 삽입 정렬
	// 입력된 노드의 포인터로 레드-블렉트리의 규칙에 맞게 정렬한다
	// 
	// Parameters: 입력된 노드의 포인터.
	// Return: (bool) 삽입 성공 여부 (true : 정렬성공 / false : 정렬실패)
	//////////////////////////////////////////////////////////////////////////
	bool InsertSorting(stNODE *pNode);


	//////////////////////////////////////////////////////////////////////////
	// 노드 삭제
	// iData값을 가진 노드를 삭제한다.
	// 
	// Parameters: 삭제할 데이터.
	// Return: (bool) 삭제 성공 여부 (true : 삭제성공 / false : 삭제실패)
	//////////////////////////////////////////////////////////////////////////
	bool DeleteNode(long long iData);
	//////////////////////////////////////////////////////////////////////////
	// 노드 삭제 정렬
	// "삭제할 노드"를 입력받아 정렬을 한다
	// 
	// Parameters: "삭제할 노드"포인터
	// Return: (bool) 삭제 성공 여부 (true : 삭제성공 / false : 삭제실패)
	//////////////////////////////////////////////////////////////////////////

	bool DeleteSorting(stNODE *pNode);

#pragma endregion

	//////////////////////////////////////////////////////////////////////////
	// 노드 찾기
	// 
	// Parameters:(int) 키값.
	// Return: (stNODE *) 키값에 대응되는 노드.
	//////////////////////////////////////////////////////////////////////////
	stNODE *Find(long long iData);


	//////////////////////////////////////////////////////////////////////////
	// 트리 출력
	// 루트부터 순회하며 트리를 출력한다
	// 
	// Parameters: (void) 없음
	// Return: (void) 없음.
	//////////////////////////////////////////////////////////////////////////
	void DisplayTree();

	//////////////////////////////////////////////////////////////////////////
	// 노드 출력
	// 
	// 
	// Parameters: 노드포인터 ,너비
	// Return: (void) 없음.
	//////////////////////////////////////////////////////////////////////////
	void DrawTree(stNODE *pNode, int iDepth);



	//////////////////////////////////////////////////////////////////////////
	// 노드 회전
	// 해당노드를 기준으로 왼쪽/오른쪽 으로 회전을 한다
	// 
	// Parameters: stNODE *회전 기준이 될 노드 포인터.
	// Return: (void) 없음.
	//////////////////////////////////////////////////////////////////////////
	void Rotate_Left(long long iData);
	void Rotate_Left(stNODE *pPivotNode);	// 왼쪽으로
	void Rotate_Right(long long iData);	// 오른쪽으로
	void Rotate_Right(stNODE *pPivotNode);	// 오른쪽으로

	bool empty() { return _root != _Nil; }
};

/*
------------------------------------------------------------------------------------------

== 15개 노드의 최고 상황 ==============================


					B

			 R               R

		 B       B       B       B

	  R    R   R   R   R   R   R   R

	N  N N  N N N N N N N N N N N N N

어떤 경우에도 4번만에 검색 가능. (15개 노드)

Root > Leaf 의 모든 경우에 대해 블랙 2회.



== 15개 노드의 레드블랙 최악 상황 =====================


					  B

			 B                   R

		 B       B         B          B

	   N  N     N  N    B     B    R     R

					   N N   N N  B  B   B   B

								 NN  NN  NN  NN


3회 ~ 5회 만에 검색 가능. (15개 노드)


- 레드의 자식은 블랙 이어야 한다

- Root > Leaf 의 블랙 개수는 모두 같아야 한다.

  위 2개의 조건으로 인해서 깊이 밸런스에 최대최소 범위가 생겨나게 된다.








최단깊이 - 블랙노드로만 이루어진 경로

최장깊이 - 블랙과 레드가 반복되는 경로

고로 최장은 최단깊이 X 2 까지 가능.



이진서치 트리에서 최악의 상황

최단깊이 - 0

최장깊이 - (노드개수 - 1)

이런 가능성도 있으므로 레드블랙 트리는 전체 밸런스가 훨씬 좋은 이진트리임




------------------------------------------------------------------------------------------
*/